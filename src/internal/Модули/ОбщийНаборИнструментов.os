#Использовать tokenizer

#Область ПрограммныйИнтерфейс

// Дополняет массив-приемник элементами из массива-источника
// 
// Параметры:
//  МассивПриемник - Массив - Массив, в который добавляются элементы
//  МассивИсточник - Массив - Массив, элементы которого копируются
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник) Экспорт

	Для Каждого Значение Из МассивИсточник Цикл
		МассивПриемник.Добавить(Значение);
	КонецЦикла;

КонецПроцедуры

// Ищет значение в соответствии по ключу без учета регистра
// 
// Параметры:
//  Соответствие - Соответствие - Соответствие для поиска
//  Ключ - Строка - Искомый ключ
// 
// Возвращаемое значение:
//  Произвольный
Функция НайтиВСоответствииПоКлючуБезУчетаРегистра(Соответствие, Ключ) Экспорт

	Для Каждого КлючИЗначение Из Соответствие Цикл
		Если НРег(КлючИЗначение.Ключ) = НРег(Ключ) Тогда
			Возврат КлючИЗначение.Значение;
		КонецЕсли;
	КонецЦикла;	

КонецФункции

// Добавляет конечный разделитель пути, если его нет
// 
// Параметры:
//  ПутьКаталога - Строка - Путь к каталогу
// 
// Возвращаемое значение:
//  Строка
Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога) Экспорт

	Если ПустаяСтрока(ПутьКаталога) Тогда
		Возврат ПутьКаталога;
	КонецЕсли;

	ПоследнийСимвол = Прав(ПутьКаталога, 1);

	Если ПоследнийСимвол = "/" Или ПоследнийСимвол = "\" Тогда
		Возврат ПутьКаталога;
	КонецЕсли;

	Разделитель = ?(СтрНайти(ПутьКаталога, "\"), "\", "/");
	
	Возврат ПутьКаталога + Разделитель;

КонецФункции

// Извлекает путь к каталогу из полного пути к файлу
// 
// Параметры:
//  ПутьКФайлу - Строка - Полный путь к файлу
// 
// Возвращаемое значение:
//  Строка
Функция КаталогФайла(ПутьКФайлу) Экспорт

	ИндексРазделителя1 = СтрНайти(ПутьКФайлу, "\", НаправлениеПоиска.СКонца);
	ИндексРазделителя2 = СтрНайти(ПутьКФайлу, "/", НаправлениеПоиска.СКонца);

	ИндексРазделителя = Макс(ИндексРазделителя1, ИндексРазделителя2);
	
	Если ИндексРазделителя Тогда
		Возврат Сред(ПутьКФайлу, 1, ИндексРазделителя - 1);
	КонецЕсли;

	Возврат "";

КонецФункции

// Дополняет путь URL именем файла
//
// - Если путь пустой, возвращает имя файла с префиксом "/"
// - Если путь заканчивается на "/", добавляет имя файла
// - Иначе возвращает путь без изменений
// 
// Параметры:
//  ПолноеИмяФайла - Строка - Полное имя файла в файловой системе
//  ПутьURL - Строка - Путь URL для дополнения
// 
// Возвращаемое значение:
//  Строка
Функция ДополнитьИменемФайлаПутьURL(ПолноеИмяФайла, ПутьURL) Экспорт

	Файл = Новый Файл(ПолноеИмяФайла);

	Если ПустаяСтрока(ПутьURL) Тогда
		Возврат "/" + Файл.Имя;
	ИначеЕсли Прав(ПутьURL, 1) = "/" Тогда
		Возврат ПутьURL + Файл.Имя;
	Иначе
		Возврат ПутьURL;
	КонецЕсли;

КонецФункции

// Проверяет, поддерживается ли протокол прокси-сервера
//
// Поддерживаются протоколы: HTTP, HTTPS, FTP, FTPS
// 
// Параметры:
//  Прокси - Строка - Протокол прокси-сервера для проверки
// 
// Возвращаемое значение:
//  Булево
Функция ПротоколПроксиПоддерживается(Прокси) Экспорт

	ПоддерживаемыеПротоколыПрокси = Новый Массив();
	ПоддерживаемыеПротоколыПрокси.Добавить(ПротоколыURL.HTTP);
	ПоддерживаемыеПротоколыПрокси.Добавить(ПротоколыURL.HTTPS);
	ПоддерживаемыеПротоколыПрокси.Добавить(ПротоколыURL.FTP);
	ПоддерживаемыеПротоколыПрокси.Добавить(ПротоколыURL.FTPS);

	Возврат ПоддерживаемыеПротоколыПрокси.Найти(Прокси) <> Неопределено;

КонецФункции

// Пытается разобрать строку как JSON
//
// В случае ошибки парсинга возвращает Неопределено
// 
// Параметры:
//  Строка - Строка - Строка для разбора как JSON
// 
// Возвращаемое значение:
//  Произвольный
Функция ПопытатьсяПрочитатьJSON(Строка) Экспорт

	Попытка

		ЧтениеJSON = Новый ЧтениеJSON();
		ЧтениеJSON.УстановитьСтроку(Строка);
		Результат = ПрочитатьJSON(ЧтениеJSON, Истина);
		ЧтениеJSON.Закрыть();

		Возврат Результат;

	Исключение

		Возврат Неопределено;

	КонецПопытки;

КонецФункции

// Проверяет наличие критичных ошибок
// 
// Параметры:
//  Ошибки - Массив из см. НоваяОшибка - Массив оишбок
// 
// Возвращаемое значение:
//  Булево
Функция ЕстьКритичныеОшибки(Ошибки) Экспорт

	Для Каждого Ошибка Из Ошибки Цикл
		Если Ошибка.Критичная Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;

	Возврат Ложь;

КонецФункции

// Создает структуру критичной ошибки
// 
// Параметры:
//  Текст - Строка - Текст ошибки
// 
// Возвращаемое значение:
//  см. НоваяОшибка
Функция НоваяКритичнаяОшибка(Текст) Экспорт
	Возврат НоваяОшибка(Текст, Истина);
КонецФункции

// Создает структуру ошибки
// 
// Параметры:
//  Текст - Строка - Текст ошибки
//  Критичная - Булево - Признак критичности ошибки
// 
// Возвращаемое значение:
//  Структура:
//   * Текст - Строка - Текст ошибки
//   * Критичная - Булево - Признак критичности ошибки
Функция НоваяОшибка(Текст, Критичная = Ложь) Экспорт
	Возврат Новый Структура("Текст, Критичная", Текст, Критичная);
КонецФункции

// Проверяет, является ли схема URL протоколом HTTP или HTTPS
// 
// Параметры:
//  Схема - Строка - Схема URL для проверки
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоHTTP(Схема) Экспорт
	Возврат Схема = ПротоколыURL.HTTP Или Схема = ПротоколыURL.HTTPS;
КонецФункции

// Проверяет, является ли схема URL протоколом FTP или FTPS
// 
// Параметры:
//  Схема - Строка - Схема URL для проверки
// 
// Возвращаемое значение:
//  Булево
Функция ЭтоFTP(Схема) Экспорт
	Возврат Схема = ПротоколыURL.FTP Или Схема = ПротоколыURL.FTPS;
КонецФункции

// Создает спецификацию токена на основе регулярного выражения
// 
// Параметры:
//  Паттерн - Строка - Паттерн регулярного выражения
//  ТипТокена - Строка - Тип токена для идентификации
// 
// Возвращаемое значение:
//  СпецификацияТокенРегулярноеВыражение
Функция ТокенРегулярноеВыражение(Паттерн, ТипТокена) Экспорт

	РегулярноеВыражение = Новый РегулярноеВыражение(Паттерн);
	РегулярноеВыражение.Многострочный = Ложь;

	Возврат Новый СпецификацияТокенРегулярноеВыражение(РегулярноеВыражение, ТипТокена);

КонецФункции

// Вычисляет хеш-строку имени переменной
//
// Использует MD5 хеширование и возвращает первые 10 символов в hex-формате
// 
// Параметры:
//  Имя - Строка - Имя переменной для хеширования
// 
// Возвращаемое значение:
//  Строка
Функция ХешСтрокаИмениПеременной(Имя) Экспорт

	ДлинаХеша = 10;

	ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.MD5);
	ХешированиеДанных.Добавить(Имя);

	ХешСтрока = Лев(ПолучитьHexСтрокуИзДвоичныхДанных(ХешированиеДанных.ХешСумма), ДлинаХеша);

	Возврат ХешСтрока;

КонецФункции

#КонецОбласти